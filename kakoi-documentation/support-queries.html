<h1 id="kakoi---design-goal-support-queries">kakoi - design goal: support queries</h1>
<p><a href="kakoi.html">kakoi</a> must allow its users to use search functionality to locate specific groups.</p>
<p>Some types of queries:</p>
<ul>
<li><p>Given a circle <code>C</code> and a positive integer <code>n</code>, return the circles nested inside of <code>C</code> until a nesting depth of <code>n</code> is reached.</p>
<p>This query will happen each time a new circle needs to be drawn on screen.</p></li>
<li><p>Given a circle <code>C</code> and a piece of text <code>T</code>, locate all circles within <code>C</code> that contain the text <code>T</code></p>
<p>This type of query is useful for locating circles to be used in further queries.</p></li>
<li><p>Given a circle <code>C</code> and a set of circles <code>S</code> that each reside inside <code>C</code>, find the smallest circles inside <code>C</code> that encloses every circle in <code>S</code>.</p>
<p>This query finds abstract connections between a set of concrete things.</p></li>
<li><p>Given a set of circles <code>S</code>, determine the set of largest circles that are contained in every circle of <code>S</code>.</p>
<p>This query finds concrete connections between a set of abstract things.</p></li>
<li><p>Given a circle <code>C</code> and some custom logical structure of circles <code>L</code>, return every circle within <code>C</code> that conforms to <code>L</code></p>
<p>This query enables custom queries.</p></li>
</ul>
<p>Non-exhaustive list of unknowns:</p>
<ul>
<li><p>How can declarative queries be implemented efficiently?</p>
<p>A declarative language for writing queries will probably be useful. For instance, we should be able to say “find the circles that satisfy this predicate” instead of “use breadth-first-search starting from x, stopping when …” and so on.</p>
<p>What Neo4j has to say about how Cypher solves this:</p>
<blockquote>
<p>Cypher is declarative, and so usually the query itself does not specify the algorithm to use to perform the search. Neo4j will automatically work out the best approach to finding start nodes and matching patterns. Predicates in WHERE parts can be evaluated before pattern matching, during pattern matching, or after finding matches. However, there are cases where you can influence the decisions taken by the query compiler. Read more about indexes in Indexes for search performance, and more about specifying hints to force Neo4j to solve a query in a specific way in Planner hints and the USING keyword.</p>
<p>– <a href="https://neo4j.com/docs/cypher-manual/current/clauses/match/#match-introduction">Neo4j documentation - MATCH</a></p>
</blockquote></li>
<li><p>How can custom data types be queried?</p>
<p>New data types should expose some kind of query functionality. For instance, a data type representing an array of integers should allow for query by numerical value. Certain arrays aught to support further queries. For instance, a sorted array should support binary search.</p>
<p>How can all of this functionality be exposed in a nice way?</p></li>
</ul>
